{"version":3,"file":"clampy.umd.js","sources":["../src/clampy.ts"],"sourcesContent":["export interface IClampOptions {\r\n  clamp?: string | \"auto\"\r\n  truncationChar?: string\r\n  truncationHTML?: string\r\n  splitOnChars?: string[]\r\n}\r\n\r\nexport interface IClampResponse {\r\n  original: string\r\n  clamped: string\r\n}\r\n\r\nexport class ClampOptions implements IClampOptions {\r\n  clamp?: string | \"auto\"\r\n  truncationChar?: string\r\n  truncationHTML?: string\r\n  splitOnChars?: string[]\r\n\r\n  constructor(\r\n    clamp?: string,\r\n    truncationChar?: string,\r\n    truncationHTML?: string,\r\n    splitOnChars?: string[]\r\n  ) {\r\n    ;(this.clamp = clamp || \"auto\"),\r\n      (this.truncationChar = truncationChar || \"…\")\r\n    this.truncationHTML = truncationHTML\r\n    this.splitOnChars = splitOnChars || [\".\", \"-\", \"–\", \"—\", \" \"]\r\n  }\r\n}\r\n\r\nexport class ClampResponse implements IClampResponse {\r\n  original: string\r\n  clamped: string\r\n\r\n  constructor(original: string, clamped: string) {\r\n    this.original = original\r\n    this.clamped = clamped\r\n  }\r\n}\r\n\r\n/**\r\n * Clamps (ie. cuts off) an HTML element's content by adding ellipsis to it if the content inside is too long.\r\n *\r\n * @export\r\n * @param {HTMLElement} element The HTMLElement that should be clamped.\r\n * @param {ClampOptions} [options] The Clamp options\r\n * @returns {ClampResponse} The Clamp response\r\n */\r\nexport function clamp(\r\n  element: HTMLElement,\r\n  options?: ClampOptions\r\n): ClampResponse {\r\n  const win = window\r\n\r\n  if (!options) {\r\n    options = {\r\n      clamp: \"auto\",\r\n      truncationChar: \"…\",\r\n      splitOnChars: [\".\", \"-\", \"–\", \"—\", \" \"]\r\n    }\r\n  }\r\n\r\n  const opt = {\r\n    clamp: options.clamp || \"auto\",\r\n    splitOnChars: options.splitOnChars || [\".\", \"-\", \"–\", \"—\", \" \"], // Split on sentences (periods), hypens, en-dashes, em-dashes, and words (spaces).\r\n    truncationChar: options.truncationChar || \"…\",\r\n    truncationHTML: options.truncationHTML\r\n  }\r\n\r\n  let splitOnChars: string[] = opt.splitOnChars.slice(0)\r\n  let splitChar: string = splitOnChars[0]\r\n  let chunks: any\r\n  let lastChunk: any\r\n  const sty = element.style\r\n  const originalText = element.innerHTML\r\n  let clampValue = opt.clamp\r\n  const isCSSValue =\r\n    clampValue.indexOf &&\r\n    (clampValue.indexOf(\"px\") > -1 || clampValue.indexOf(\"em\") > -1)\r\n  let truncationHTMLContainer: any\r\n\r\n  if (opt.truncationHTML) {\r\n    truncationHTMLContainer = document.createElement(\"span\")\r\n    truncationHTMLContainer.innerHTML = opt.truncationHTML\r\n  }\r\n\r\n  // UTILITY FUNCTIONS __________________________________________________________\r\n  /**\r\n   * Return the current style for an element.\r\n   * @param {HTMLElement} elem The element to compute.\r\n   * @param {string} prop The style property.\r\n   * @returns {number}\r\n   */\r\n  function computeStyle(elem: HTMLElement, prop: string) {\r\n    return win.getComputedStyle(elem).getPropertyValue(prop)\r\n  }\r\n\r\n  /**\r\n   * Returns the maximum number of lines of text that should be rendered based\r\n   * on the current height of the element and the line-height of the text.\r\n   */\r\n  function getMaxLines(height?: number) {\r\n    const availHeight = height || element.clientHeight\r\n    const lineHeight = getLineHeight(element)\r\n\r\n    return Math.max(Math.floor(availHeight / lineHeight), 0)\r\n  }\r\n\r\n  /**\r\n   * Returns the maximum height a given element should have based on the line-\r\n   * height of the text and the given clamp value.\r\n   */\r\n  function getMaxHeight(clmp: number) {\r\n    const lineHeight = getLineHeight(element)\r\n    return lineHeight * clmp\r\n  }\r\n\r\n  /**\r\n   * Returns the line-height of an element as an integer.\r\n   */\r\n  function getLineHeight(elem: HTMLElement): number {\r\n    let lh: any = computeStyle(elem, \"line-height\")\r\n    if (lh === \"normal\") {\r\n      // Normal line heights vary from browser to browser. The spec recommends\r\n      // a value between 1.0 and 1.2 of the font size. Using 1.1 to split the diff.\r\n      lh =\r\n        parseFloat(parseFloat(computeStyle(elem, \"font-size\")).toFixed(0)) * 1.1\r\n    }\r\n    return parseFloat(parseFloat(lh).toFixed(0))\r\n  }\r\n\r\n  /**\r\n   * Returns the height of an element as an integer (max of scroll/offset/client).\r\n   * Note: inline elements return 0 for scrollHeight and clientHeight\r\n   */\r\n  function getElemHeight(elem: HTMLElement): number {\r\n    return Math.max(elem.scrollHeight, elem.offsetHeight, elem.clientHeight)\r\n  }\r\n\r\n  /**\r\n   * Gets an element's last child. That may be another node or a node's contents.\r\n   */\r\n  function getLastChild(elem: HTMLElement): any {\r\n    if (!elem.lastChild) {\r\n      return\r\n    }\r\n    // Current element has children, need to go deeper and get last child as a text node\r\n    if (elem.lastChild.childNodes && elem.lastChild.childNodes.length > 0) {\r\n      return getLastChild(Array.prototype.slice.call(elem.children).pop())\r\n    } else if (\r\n      !elem.lastChild ||\r\n      !elem.lastChild.nodeValue ||\r\n      elem.lastChild.nodeValue === \"\" ||\r\n      elem.lastChild.nodeValue === opt.truncationChar\r\n    ) {\r\n      // This is the absolute last child, a text node, but something's wrong with it. Remove it and keep trying\r\n      if (elem.lastChild.parentNode) {\r\n        elem.lastChild.parentNode.removeChild(elem.lastChild)\r\n        return getLastChild(element)\r\n      }\r\n    } else {\r\n      // This is the last child we want, return it\r\n      return elem.lastChild\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply the ellipsis to the element\r\n   * @param elem the element to apply the ellipsis on\r\n   * @param str The string that will be set to the element\r\n   */\r\n  function applyEllipsis(elem: HTMLElement, str: string) {\r\n    elem.nodeValue = str + opt.truncationChar\r\n  }\r\n\r\n  /**\r\n   * Removes one character at a time from the text until its width or\r\n   * height is beneath the passed-in max param.\r\n   */\r\n  function truncate(target: HTMLElement, maxHeight: number): any {\r\n    /**\r\n     * Resets global variables.\r\n     */\r\n    function reset() {\r\n      splitOnChars = opt.splitOnChars.slice(0)\r\n      splitChar = splitOnChars[0]\r\n      chunks = null\r\n      lastChunk = null\r\n    }\r\n\r\n    if (!target || !maxHeight || !target.nodeValue) {\r\n      return\r\n    }\r\n\r\n    const nodeValue = target.nodeValue.replace(opt.truncationChar, \"\")\r\n\r\n    // Grab the next chunks\r\n    if (!chunks) {\r\n      // If there are more characters to try, grab the next one\r\n      if (splitOnChars.length > 0) {\r\n        splitChar = splitOnChars.shift()!\r\n      } else {\r\n        // No characters to chunk by. Go character-by-character\r\n        splitChar = \"\"\r\n      }\r\n\r\n      chunks = nodeValue.split(splitChar)\r\n    }\r\n\r\n    // If there are chunks left to remove, remove the last one and see if\r\n    // the nodeValue fits.\r\n    if (chunks.length > 1) {\r\n      lastChunk = chunks.pop()\r\n      applyEllipsis(target, chunks.join(splitChar))\r\n    } else {\r\n      // No more chunks can be removed using this character\r\n      chunks = null\r\n    }\r\n\r\n    // Insert the custom HTML before the truncation character\r\n    if (truncationHTMLContainer) {\r\n      target.nodeValue = target.nodeValue.replace(opt.truncationChar, \"\")\r\n      element.innerHTML =\r\n        target.nodeValue +\r\n        \" \" +\r\n        truncationHTMLContainer.innerHTML +\r\n        opt.truncationChar\r\n    }\r\n\r\n    // Search produced valid chunks\r\n    if (chunks) {\r\n      // It fits\r\n      if (element.clientHeight <= maxHeight) {\r\n        // There's still more characters to try splitting on, not quite done yet\r\n        if (splitOnChars.length >= 0 && splitChar !== \"\") {\r\n          applyEllipsis(target, chunks.join(splitChar) + splitChar + lastChunk)\r\n          chunks = null\r\n        } else {\r\n          // Finished!\r\n          return element.innerHTML\r\n        }\r\n      }\r\n    } else {\r\n      // No valid chunks produced\r\n      // No valid chunks even when splitting by letter, time to move\r\n      // on to the next node\r\n      if (splitChar === \"\") {\r\n        applyEllipsis(target, \"\")\r\n        target = getLastChild(element)\r\n\r\n        reset()\r\n      }\r\n    }\r\n\r\n    return truncate(target, maxHeight)\r\n  }\r\n\r\n  // CONSTRUCTOR ________________________________________________________________\r\n  if (clampValue === \"auto\") {\r\n    clampValue = getMaxLines().toString()\r\n  } else if (isCSSValue) {\r\n    clampValue = getMaxLines(parseInt(clampValue, 10)).toString()\r\n  }\r\n\r\n  let clampedText\r\n  const height = getMaxHeight(Number(clampValue))\r\n  if (height < getElemHeight(element)) {\r\n    clampedText = truncate(getLastChild(element), height)\r\n  }\r\n\r\n  return new ClampResponse(originalText, clampedText)\r\n}\r\n"],"names":[],"mappings":"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"}